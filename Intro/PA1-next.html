<!DOCTYPE html>
<html>
<head>
<title>PA1-next</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<p><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script></p>
<p><img src="figs/cover.png" alt="cover" /></p>
<h1><center><font color=#2F5496 face="宋体" size="三号"> <strong>计算机原理PA1下 —— NEMU完善</strong> </font></center></h1>
<p><font face="宋体" size="小四">我们在PA1中已经对NEMU的框架代码进行了一番阅读。通过完成PA1中的表达式求值1和简易调试器1，我们对NEMU的工作流程，<code>ui_mainloop</code>对用户输入的响应已经有了更加深入的了解。在PA1的整个过程中，我们的NEMU系统并不能直接从<code>pc</code>取指，并用<code>ALU</code>进行运算。实际上，整个系统是由<code>NEMU</code>和用户一起构成的。</br></p>
<p><font face="宋体" size="小四">下面请将你自己想象成一个简易<code>CPU</code>，你的手里有一个“指令”集合：<code>echo, help, p, ls, pwd, info ...</code>，而你自身有一个随机的<code>pc</code>，每次你将会随机从“指令”集合中抽取一条指令，然后交由<code>NEMU</code>执行。在这个过程中，你充当了<code>pc</code>取指的角色(<code>cpu</code>)，而整个计算机系统还需要计算单元、控制部件、存储器等。回想一下已经实现的<code>expr.c</code>，当你输入<code>p 1+1</code>时这条“指令”时，是<code>NEMU</code>帮你完成了计算过程，并返回给你计算结果，此时的<code>expr.c</code>中的<code>expr</code>函数实际上就相当于一个<code>ALU</code>。而<code>NEMU</code>的存储器并没有发挥作用，因为整个存储器是你的大脑，<em>是你的大脑随机从你的大脑中取出了一条条“指令”</em>，并交由<code>NEMU</code>执行。PA1整个过程将使用上述的一种“系统”，因此在后续过程中，请将你自己抽象为<code>NEMU</code>的<code>pc</code>和存储器，并将<code>C</code>语言看作<code>NEMU</code>系统的机器级语言，而将<code>C</code>语言级别以下的二进制指令码、汇编代码全部忽略掉(PA2的主要内容)。</p>
<p><font face="宋体" size="小四">如上面所述，PA1上我们完成了整个系统的<code>ALU</code>部分，要注意到你现在充当了<code>CPU</code>和存储器的角色了。因此我们还需要实现一个简易的控制单元用于检查内存中数据的流动及传输。当然这里的控制单元与<code>CU</code>有区别(<code>CU</code>是自动逐条取指并译码)。由于取指已经由大脑实现，而译码已经由<code>ui.c</code>实现，此处的控制单元实际上是指对系统状态进行监视的组件(monitor)。为了避免混淆，以下均使用监视器来代替。事实上，PA1的简易调试器1已经有了监视器初级的功能，比如逐条执行指令(<code>si</code>)，扫描内存(<code>x</code>)，查看寄存器(<code>info r</code>)等。但是我们还无法真正进行监视，因为我们只能进行查看而无法进行控制，比如我们要对寄存器<code>%eax</code>进行监视，然而我们只能通过<code>info r</code>来查看寄存器<code>%eax</code>的值。</p>
<p><font face="宋体" size="小四">因此，PA1下的重点就是完善这个监视器。在完善监视器前我们先对监视做一些直观介绍。</p>
<p><font face="宋体" size="小四">监视	，回想一下高中教师外班主任鹰隼般锐利的目光，即使远处墙外，也能带来一股无形的压迫力。一旦出现异常举止，下一秒就带着疲倦的风来到你的位置。此处的监视也类似：<strong>随时检查监视的目标是否出现异常变化</strong>。一个监视由监视目标和定义异常和处理异常三部分组成。比如下面的例子：</p>
<pre><code>watch nemu_state.state == NEMU_GOOD
</code></pre>

<p><font face="宋体" size="小四"><code>watch</code>后面指定了监视对象为<code>nemu_state.state</code>，而异常条件为<code>nemu_state.state!=NEMU_GOOD</code>。其作用就是监视<code>NEMU</code>的运行状态是否健康，一旦状态由于不知名的修改而改变，立马执行异常处理(一般都是终止指令执行，将控制权交由用户)。在<code>NEMU</code>实现一次监视需要指明监视目标，定义异常条件，实现异常处理。</p>
<p><font face="宋体" size="小四">看到上面的<code>watch nemu_state == NEMU_GOOD</code>，你是否回想起了PA1上在<code>ui.c</code>里面实现的命令(如<code>p 1+1</code>)。事实上，一个监视命令需要在<code>ui.c</code>里面附加实现一个<code>w</code>命令，然后通过将后面的异常条件(其实就是表达式)进行表达式求值即可。</p>
<p><font face="宋体" size="小四">由此，实现一个监视命令实际上还是和表达式求值相关。因此本次PA1下主要分为以下内容：</p>
<blockquote>
<ul>
<li><a href="#preparation">前置准备</a></li>
<li><a href="#references">参考资料</a></li>
<li>
<a href="#expr2">表达式求值2</a>
<ul>
<li><a href="#test1">表达式求值测试1</a></li>
<li><a href="#expr-expand">表达式求值扩展</a></li>
<li><a href="#test2">表达式求值测试2</a> </li>
</ul>
</li>
<li>
<a href="#monitor2">简易调试器2</a> 
<ul>
<li><a href="#watchpoint">实现监视点</a></li>
<li><a href="#command-expand">命令扩充</a></li>
<li><a href="#monitor-function">实现监视功能</a></li>
</ul>
</li>
<li><a href="#file-handin">提交文件说明</a></li>
</ul>
</blockquote>
<div id="preparation"></div>
<h2></h2>
<h2><font color=#2F5496 face="宋体" size="小三"><strong>前置准备</strong> </font></h2>
<p><font face="宋体" size="小四" color="black">正式开始本次PA1之前，请大家先按照以下命令做好git项目的分支管理</p>
<pre><code>cd ~/ics2020 ## 进入ics项目
git branch ## 查看分支
git checkout pa1 ## 确保在pa1分支下
</code></pre>

<p><font face="宋体" size="小四" color="black">一定要保证你当前的分支是<code>pa1</code>，然后下载我们上传到Elearning的文件压缩包，解压出六个文件(<code>codes</code>文件夹下)：</p>
<blockquote>
<ul>
<li>gen-expr.c，复制到<code>nemu/tools/gen-expr/</code>下面</li>
<li>watchpoint.h 复制到<code>nemu/include/monitor/watchpoint.h</code>下面</li>
<li>watchpoint.c 复制到<code>nemu/src/monitor/debug/</code>下面</li>
<li>psmd.txt复制到<code>nemu/src/</code>下面(不会提醒替换文件)</li>
<li>test.txt复制到<code>nemu/src/</code>下面(不会提醒替换文件)</li>
<li>main.c复制到<code>nemu/src/</code>下面</li>
</ul>
</blockquote>
<p><font face="宋体" size="小四" color="black">复制的时候如果没有提醒你替换文件，请核对复制的文件路径。</p>
<div id="references"></div>
<h2></h2>
<h2><font color=#2F5496 face="宋体" size="小三"><strong>参考资料</strong> </font></h2>
<p>为了顺利完成PA1上的内容，我们首先给出以下参考资料：</p>
<blockquote>
<ul>
<li>南大NJU gitbook：<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/1.5.html">链接</a></u></li>
</ul>
</blockquote>
<div id="expr2"></div>
<h2></h2>
<h2><font color=#2F5496 face="宋体" size="小三"><strong>表达式求值2</strong> </font></h2>
<div id="test1"></div>
<h3><font color=#2F5496 face="宋体" size="小三"><strong>表达式求值测试1</strong> </font></h3>
<hr />
<p><font face="宋体" size="小四" color="black">在PA1中，我们以合法的token集合：数字<code>[0-9]</code>、<code>0x</code>、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>(</code>、<code>)</code>、<code>空格</code>、<code>==</code>、<code>a-f/A-F</code>通过完成<code>expr.c</code>实现了简单的表达式求值。然而，由于复杂的token正则表达式识别、识别顺序、运算符优先级等因素，导致虽然会给出结果，但是难以保证我们的结果是正确的。</p>
<p><font face="宋体" size="小四" color="black">一种保证程序正确性的方法就是用大量用例进行测试，比如在<code>lab1</code>中，我们通过大量随机生成的用例测试大家完成的<code>operations.c</code>中各项函数。因此在表达式求值中，我们也需要使用大量用例对其进行测试。此处我们为大家准备了一组测试样例(<code>psmd.txt</code>)，由随机生成的248组表达式及其准确值组成，样例如下(左边是表达式的正确结果，右边是对应表达式)：</p>
<pre><code>4294921411 ( 16+96/(35/((42))-42-38+7)- 60*17*45)
132 82+(95-34)-13*50/(((59)))
0 19/(89-  31*(18)+87)
1094 98/ 89*( (58)/21)+42*(26)
4294946953  46+ 45-(23)*37*24-10
4294961034  97*88*13/(84)-96*79+1
6  8/21+82-76-88*71*7/( 70*8-63*((40))*83)
430 66/11+84+   ((3)+7)*34
391598 80*55*89+ 62-(62)+(( 4-20+ 14))
4294955193  ((22)+68-  (47/80/  65*13+97*98+33*(83)+83* (78/92)))+52-88/41*1/(99/29)
</code></pre>

<p><font face="宋体" size="小四" color="black">这组样例只包含了加减乘除基本四则运算。为了测试你的表达式求值，只需要在<code>main</code>函数里逐行读入文件内容，比较正确结果和你的<code>expr(char * args, bool * success)</code>的运行结果即可。为了保证结果的格式，请将你的<code>expr(char *, bool *)</code>函数的返回值设置为<code>unsigned</code>类型。为了方便测试，我们已经在<code>main.c</code>里实现了逐行读取并测试的函数，所以只需要将测试样例<code>psmd.txt</code>复制到<code>nemu/src</code>下，将<code>expr(char *, bool *)</code>返回值修改为<code>unsigned</code>类型，用<code>make ISA=x86 run</code>编译即可。</p>
<p><font face="宋体" size="小四" color="black">如果你觉得测试样例不够多，样例运算符类型较少，请移步至表达式求值测试2部分。</p>
<p>如果执行后的结果如下图所示，说明你的表达式求值对四则运算基本上是正确的。为了通过表达式求值测试1，请从以下几个方面进行思考：</p>
<ul>
<li>tokens数量是否足够</li>
<li>递归求值是否会栈溢出</li>
<li>是否处理掉了空格</li>
</ul>
<p><img src="figs/expr-test1.png" alt="expr-test1" /></p>
<p>如果出现错误用例，界面上也会输出对应错误样例。如下图所示：</p>
<p><img src="figs/expr-test1-wrong.png" alt="expr-test1-wrong" /></p>
<p>到此，对表达式求值1的测试完成。</p>
<h2></h2>
<div id="test1"></div>
<h3><font color=#2F5496 face="宋体" size="小三"><strong>表达式求值扩展</strong> </font></h3>
<hr />
<p>我们进行表达式求值的目的在于实现监视器(monitor)。实际上，仅仅有四则运算基本上对监视点没有帮助。回想一下在lab2中的GDB设置断点(断点是程序运行到此处停止，监视点是检查到不同行为停止)，比如下面的例子：</p>
<pre><code>break * 0x800482c
break phase_1
</code></pre>

<p>这两个例子根本就没有用到四则运算，再如我们对寄存器<code>%eax</code>进行监视，使用命令<code>w $eax</code>，也不会使用到四则运算。这告诉我们需要对表达式求值进行扩充。为此，我们总结出以下<code>token</code>集合(PA1下要求实现)：</p>
<ul>
<li>四则运算(<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>(</code>、<code>)</code>)，即加减乘除和括号</li>
<li>逻辑运算(<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>、<code>==</code>、<code>!=</code>)</li>
<li>指针解引用(<code>*</code>)，如<code>*0x100000</code>表示访问内存中<code>0x100000</code>处的<code>4</code>字节</li>
<li>寄存器和<code>pc</code>操作(<code>$</code>)，如<code>$eax, $ebx, $pc</code>等</li>
<li>数字和16进制(<code>[0-9]</code>、<code>0x[0-9|a-f|A-F]</code>)</li>
<li>特殊符号(<code>-</code>负号)</li>
</ul>
<p>特别的，对应的BNF如下：</p>
<pre><code>&lt;expr&gt; ::= &lt;number&gt;    # 一个数是表达式
| &quot;(&quot; &lt;expr&gt; &quot;)&quot;     # 在表达式两边加个括号也是表达式
| &lt;expr&gt; &quot;+&quot; &lt;expr&gt;  # 两个表达式相加也是表达式
| &lt;expr&gt; &quot;-&quot; &lt;expr&gt;  # 运算符连接表达式仍然是表达式
| &lt;expr&gt; &quot;*&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;/&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;&amp;&amp;&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;||&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;==&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;!=&quot; &lt;expr&gt;
| &quot;*&quot; &lt;expr&gt; # 指针解引用
| &quot;-&quot; &lt;expr&gt; # 负号连接表达式
| &quot;$&quot; &lt;registers/pc&gt; ## $eax, $pc也是表达式($rax等非法输入需要识别并抛出错误)
</code></pre>

<p>除了寄存器和<code>pc</code>操作外，其余运算符的优先级和<code>C</code>语言的规定相同。</p>
<p>为了将寄存器和<code>pc</code>的<code>token</code>转化为具体值，你还需要完成<code>nemu/src/isa/x86/reg.c</code>下的<code>isa_reg_str2val</code>函数，你的函数对非法寄存器应该要做对应的处理(<code>assert</code>或者放弃本次计算均可)。</p>
<p>为了正确识别并处理表达式，你还需要注意以下两方面：</p>
<ul>
<li>重复<code>token</code>的区分</li>
<li>双目运算符和单目运算符的不同</li>
</ul>
<p>以下分别对其进行说明：</p>
<p><strong>重复token的区分</strong></p>
<p>重复的<code>token</code>有两种，一是符号和减号，而是乘法运算符和指针解引用。实际上，如果用后缀表达式(波兰表达式)，那么此类token将能得到更好的区分并且无需考虑优先级。例如</p>
<pre><code>a - b  =====&gt; ab-
-a - b =====&gt; a-b-
</code></pre>

<p>然而如果以前缀表达式，那么token的表示将能更加直观，例如：</p>
<pre><code>a - b  =====&gt; -ab
-a - b =====&gt; --ab
</code></pre>

<p>如果你对<code>lambda表达式</code>或者<code>Clojure</code>语言有所了解，那么前缀表达式的形式和其非常相似，例如：</p>
<pre><code>(- a b) ## 表示 a - b
</code></pre>

<p>再如下图表示<code>--12</code>，<code>-1-2</code>的前缀表达式在<code>Clojure</code>中的结果，而在<code>Clojure</code>中，<strong>万物皆函数</strong>。由此，你是否对运算符有了新的理解——从函数上理解运算符。实际上，一个运算符做的事情，无非就是<code>func(a, ...)</code>的简化版本，而两个函数的不同体现在函数名、函数参数上面。如果我们把运算符看做函数名，那么区分同一个函数名的不同函数就得通过函数参数了！这也正是我们区分减号和符号，乘法与指针解引用的关键。</p>
<p><img src="figs/closure.png" alt="closure" /></p>
<p>由于我们的表达式求值使用的是中缀表达式，也就是<code>var1 op var2</code>或者<code>op var</code>的形式，因此区分token就变成从<code>var1</code>进行区分了。也就是检查运算符前面的<code>token</code>。如果你对前面我们从不同角度理解表达式有了共鸣，那么你一定会自然地认为检查运算符前面的<code>token</code>一定是对的。简单来说，如果两个<code>op</code>是一样的，一个是<code>var1 op var2</code>，另一个是<code>op var</code>，并且<code>var2</code>与<code>var</code>的属性相同，那么两个<code>op</code>前面的部分一定不同，否则将变为同一个<code>op</code>，那么也就不需要区分了。</p>
<p>从实际操作上来说，只需在<code>make_token</code>函数中对重复运算符进行检测即可。比如对<code>-</code>的检测伪代码如下：</p>
<pre><code>int judge_minus(int index):
  if(index == 0 || tokens[index-1] is in certain type set)
    return TK_NEG
  else
    return TK_MINUS
</code></pre>

<p>也即，我们只需要再定义一个运算符判断函数<code>judge_minus</code>，在<code>make_token</code>函数里面只需要调用它，即可自动对运算符进行精准分类了。上面伪代码中<code>certain type set</code>就是区分负号和减号的关键了，留给大家思考并实现。</p>
<p><strong>双目运算符和单目运算符的不同</strong></p>
<p>第二个需要考虑的点则是双目运算符和单目运算符的不同了。按照中缀表达式，全由双目运算符构成的表达式始终是沿着<code>val op val</code>的路径运行下去，事实上在表达式求值1里就是这样做的。其部分核心伪代码如下：</p>
<pre><code>val_left = eval(start, mainop-1)
val_right = eval(mainop+1, end)
return val_left op val_right
</code></pre>

<p>然而，一旦表达式里混入了单目运算符，计算路径就不再是<code>val op val</code>了，例如表达式<code>1--1</code>，按照双目运算符的规则，我们将得到<code>1-</code>、<code>-</code>、<code>1</code>的分裂结果，即<code>(1-) - (1)</code>，这显然不符合实际要求。这是因为单目运算符只会用到右侧的表达式而对左侧不做处理，而双目运算符既要考虑左侧也要考虑右侧。再如，俄罗斯套娃式的死亡嵌套：</p>
<pre><code>----------------1
</code></pre>

<p>人眼不难看出，这全是单目运算符，因此表达式为<code>(-1)^n</code>，<code>n</code>为负号的个数，然而，把它丢进表达式求值1的函数里面，却无法得到正确的结果。因此需要对双目运算符和单目运算符分别进行考虑。由于前面我们已经对其进行了区分，也即我们知道单目和双目出现的地方，因此有以下办法：</p>
<ul>
<li>单目变双目。在单目运算符左侧添加“空值”，不改变原表达式结果而转换为双目表达式</li>
<li>统计连续单目运算符个数，直接将其变为具体值，从而可以使用双目表达式求值</li>
<li>分别对运算符的特征做考虑</li>
</ul>
<p><font face="宋体" size="小四" color="Sienna"><strong>思考:上述前两种方法的弊端之处，第三种方法有哪些方面可以考虑，请给出你的具体思路和代码实现。并将其附在最后的实验报告内容中。</strong></p>
<p><font face="宋体" size="小四" color="black">扩展了以上<code>token</code>和表达式后，你的表达式求值功能更加强大。几个测试样例如下图所示(因为<code>Log</code>打印结果太多，这里把它去掉了)也就更容易因为运算符优先级和多种运算符出现<code>bug</code>了。因此我们下面将进行表达式求值测试第二部分。</p>
<p><img src="figs/expr-test2.png" alt="expr-test2" />
其中有几个样例是俄罗斯套娃系列，可以用来挑战你的表达式求值函数。</p>
<h2></h2>
<div id="test2"></div>
<h3><font color=#2F5496 face="宋体" size="小三"><strong>表达式求值测试2</strong> </font></h3>
<hr />
<p><font face="宋体" size="小四" color="black">此小节我们对表达式求值函数进行测试。</p>
<p>为了测试表达式求值函数，我们需要的是大量的测试样例及正确结果(颇有些测试神经网络模型的意味)。而如何产生表达式和如何计算正确结果即是需要解决的问题。以下我们分别对其进行详细介绍。</p>
<p><strong>随机生成表达式</strong></p>
<p>要生成一个表达式，就需要利用表达式的规则。毫无疑问，上面定义的BNF即是所需规则，这里把它复制一遍</p>
<pre><code>&lt;expr&gt; ::= &lt;number&gt;    # 一个数是表达式
| &quot;(&quot; &lt;expr&gt; &quot;)&quot;     # 在表达式两边加个括号也是表达式
| &lt;expr&gt; &quot;+&quot; &lt;expr&gt;  # 两个表达式相加也是表达式
| &lt;expr&gt; &quot;-&quot; &lt;expr&gt;  # 运算符连接表达式仍然是表达式
| &lt;expr&gt; &quot;*&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;/&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;&amp;&amp;&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;||&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;==&quot; &lt;expr&gt;
| &lt;expr&gt; &quot;!=&quot; &lt;expr&gt;
| &quot;*&quot; &lt;expr&gt; # 指针解引用
| &quot;-&quot; &lt;expr&gt; # 负号连接表达式
| &quot;$&quot; &lt;registers/pc&gt; ## $eax, $pc也是表达式($rax等非法输入需要识别并抛出错误)
</code></pre>

<p>BNF实际上给出了表达式的一个递归过程。其中的<code>&lt;expr&gt;</code>可以看做是<code>gen_rand_expr()</code>的结果。那么整个生成过程(递归过程)伪代码如下：</p>
<pre><code>void gen_rand_expr(){
  switch(choose(num)){ // choose(num)表达式随机取一个数字对num取模
    case 0:
      gen_blank(); // 生成随机空格
      gen_rand_expr(); // 空格+表达式是表达式
      break;
    case 1:
      gen_num(); // 生成随机数字
      break; // 数字是表达式
    case 2:
      gen_rand_expr(); 
      gen_rand_op(); // 产生随机操作符
      gen_rand_expr(); // &lt;expr&gt; &quot;op&quot; &lt;expr&gt;是表达式
      break;
    case 3:
      gen_left_bra();
      gen_rand_expr();
      gen_right_expr(); // &quot;(&quot; &lt;expr&gt; &quot;)&quot;也是表达式
      break;
    case 4:
      /* generate expression for unary operator, such as &quot;!&quot;
       */
     default:
      /* handle other cases if needed */
   }
}
</code></pre>

<p>上述产生随即表达式函数定义在<code>nemu/tools/gen-expr/gen-expr.c</code>。为了检查你的表达式求值函数，你需要完成上述伪代码中多个函数的定义。<code>switch</code>下的<code>case</code>数量根据实际需要进行调整，<code>case</code>下的处理也可以自行调整。(要求实现BNF中所有的双目运算符，单目运算符只需要&quot;!&quot;，括号，空格)。<strong>你只需要完成gen_rand_expr函数，将表达式写入buf数组中即可。</strong></p>
<p><font face="宋体" size="小四" color="Sienna"><strong>[思考1]:上述递归调用返回入口在哪里，怎样避免一直递归下去；同时为了让你的表达式求值能正常计算，你产生的表达式不能太长，怎么控制生成的表达式长度；生成的表达式遇到除0怎么避免。请在你的实验报告中对这三点做出解答，并设计对应的解决方案</strong></p>
<p><font face="宋体" size="小四" color="Sienna"><strong>[思考2]:假设随机数是均匀分布的，你的case数量一共有N种，那么你的生成表达式函数理论上递归的次数与N满足怎样的关系，从这里你是否对思考1中怎样控制表达式长度已有一定的解决思路。思考2不要求在实验报告中完成(因为属于算法的知识)，做为选做思考题。</strong></p>
<p><font face="宋体" size="小四" color="black">为了生成自己的测试样例，请编译<code>gen-expr.c</code>并运行，如下所示：</p>
<pre><code>gcc gen-expr.c -o gen-expr ## compile
./gen-expr 1000 &gt; test.txt ## generate 1000 examples into test.txt
</code></pre>

<p><font face="宋体" size="小四" color="black">以下是一些生成样例，你可以作为参考(我们也提供了50样例的复杂表达式文件<code>nemu/src/test.txt</code>)：</p>
<pre><code>(55)*71==29&amp;&amp;!2&amp;&amp;47||!33-75+78||!55&amp;&amp;62==54==((51+!3||17))
(49)==((( (70))/17)==1!=( 87-!57/78&amp;&amp;! 25!=37!=(56)* (81*68/77!=55/59&amp;&amp;!52||9!=86+!79+(91)-!80!=!59*!16)&amp;&amp;41!=!80||79/(27&amp;&amp; 91)))+( 85==32==!  19==76&amp;&amp;!39)&amp;&amp; ((64)==42/ 52)*(13==79||!34*51+!9+!74)
(33-!72+!79!=!(  0==!32* 22== 48==!(43-((42)-64==45!=! 50-64&amp;&amp;!54)/2)!=! 18!=29!=99&amp;&amp;25/98||44))
</code></pre>

<p><strong>计算表达式正确结果</strong></p>
<p>生成表达式之后，就需要对其进行求值了。这只需要我们将整个过程塞到一个函数里面即可。实际上<code>nemu/tools/gen-expr/gen-expr.c</code>中你只需要把生成的表达式放在<code>char buf[65536]</code>这个字符数组里即可。如下所示：</p>
<pre><code>#include &lt;stdio.h&gt;
int main() {
  unsigned result = buf; // 把???替换成表达式
  printf(&quot;%u&quot;, result);
  return 0;
}
</code></pre>

<p>在<code>gen-expr.c</code>的<code>main</code>函数将上面的函数包装为字符串，写入一个C文件，用<code>system</code>进行编译和执行即可得到正确结果了。此部分NEMU框架已经实现好了。</p>
<p><strong>测试的局限性</strong></p>
<p>上述<code>gen_rand_expr</code>函数还有一些局限：</p>
<ul>
<li>生成表达式长度有限制，这是由于表达式求值函数<code>expr</code>的<code>tokens</code>数组和<code>eval</code>函数递归深度有限</li>
<li>运算符测试有限，我们无法对寄存器和指针进行测试</li>
<li>样例有限，生成过多样例，很容易出现除0错误，比如<code>86/!(4*2)</code></li>
</ul>
<p>事实上，没有一劳永逸的测试。进行一项测试往往需要大量的时间和精力。如果测试能说明程序在大量普通测试用例上都是正确的，那也是不错的结果。因为极大概率上处理的都是普通的例子。</p>
<div id="minitor2"></div>
<h2></h2>
<h2><font color=#2F5496 face="宋体" size="小三"><strong>简易调试器2</strong> </font></h2>
<p>实现了表达式求值后，接下来的工作就是使用它完成监视器了。此部分分为三节：实现监视器、命令扩充、实现监视功能。</p>
<h2></h2>
<div id="watchpoint"></div>
<h3><font color=#2F5496 face="宋体" size="小三"><strong>实现监视点</strong> </font></h3>
<hr />
<p>简易调试器应该允许用户通过设置多个监视点, 删除监视点来监视程序运行状态。NEMU框架中使用了链表来组织监视点结构。 监视点的结构体定义如下(在<code>nemu/include/monitor/watchpoint.h</code>中)</p>
<pre><code>typedef struct watchpoint {
  int NO;
  struct watchpoint *next;

  /* TODO: Add more members if necessary */


} WP;
</code></pre>

<p>但此结构体中只定义了两个成员: NO表示监视点的序号, next就不用多说了吧。为了实现监视点的功能, <strong>你需要根据你对监视点工作原理的理解在结构体中增加必要的成员</strong>。同时我们使用&quot;池&quot;的数据结构来管理监视点结构体, 框架代码中已经给出了一部分相关的代码(在<code>nemu/src/monitor/debug/watchpoint.c</code>中):</p>
<pre><code>static WP wp_pool[NR_WP];
static WP *head, *free_;
</code></pre>

<p>但NEMU框架这样设计是冗余的，因为采用了结构数组的方式定义，访问数组只需要用索引值就可以。因此这部分设计是可以进行自由设计的。(请阅读<code>nemu/src/monitor/debug/watchpoint.c</code>中的<code>init_wp_pool</code>函数辅助理解)</p>
<p>首先还是对框架中<code>*head</code>, <code>*free_</code>进行说明。实际上一个监视点池分为两部分：已使用和空闲池。<code>*head</code>则是指向已使用链表的头指针，而<code>free_</code>则是指向空闲池链表的头指针。</p>
<p>实际上，只需要一个<code>static int free</code>作为已使用和空闲池分界的索引即可。</p>
<p>为了使用监视点，你需要在<code>nemu/src/monitor/debug/watchpoint.c</code>中定义并实现以下函数(为了方便函数调用，还需要在<code>nemu/include/monitor/watchpoint.h</code>中声明以下函数)：</p>
<pre><code>WP * new_wp(type1 param1, ...) // 新建监视点
void * free_wp(type1 param1, ...) // 删除监视点
void print_wp(type1 param1, ...) // 打印监视点信息
void delete_all_wp() // 释放所有监视点
</code></pre>

<h2></h2>
<div id="command-expand"></div>
<h3><font color=#2F5496 face="宋体" size="小三"><strong>命令扩充</strong> </font></h3>
<hr />
<p>实现了监视点之后。我们就可以在<code>nemu/src/monitor/debug/ui.c</code>中添加新的命令了。这次需要新添加命令如下表：</p>
<table>
<thead>
<tr>
	<th align="center">命令</th>
	<th align="center">格式</th>
	<th align="center">使用举例</th>
	<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
	<td align="center">程序状态</td>
	<td align="center">info subcmd</td>
	<td align="center">info w</td>
	<td>打印监视点信息</td>
</tr>
<tr>
	<td align="center">设置监视点</td>
	<td align="center">w</td>
	<td align="center">w &lt;expr&gt;</td>
	<td>设置监视点，监视条件为表达式的值发生变化</td>
</tr>
<tr>
	<td align="center">删除监视点</td>
	<td align="center">d</td>
	<td align="center">d 1</td>
	<td>删除指定序号监视点，缺省时删除所有监视点</td>
</tr>
</tbody>
</table>
<p>扩充后的运行截图如下(仅供参考)：</p>
<p>help命令截图：</p>
<p><img src="figs/help.png" alt="help" /></p>
<p>设置监视点和删除监视点和删除所有监视点：</p>
<p><img src="figs/watchpoint.png" alt="watchpoint" />
监视点设置和删除请参考GDB的断点设置和删除</p>
<p>设置了监视点后，我们作为<code>CPU</code>就可以随时监控NEMU的运行状态了，然而理想很丰满，显示很骨感。如果你设置了监视点<code>w $eax</code>用于监视寄存器<code>%eax</code>的值是否变化，那么输入命令<code>c</code>，将不会出现暂停。然而PA1上我们提到了<code>movl 0x1234, %eax</code>是第一行客户程序指令，这句指令执行后，<code>%eax</code>的值必然发生变化，然而程序运行并没有中止。</p>
<p>仔细思考你实现监视点和监视点命令的过程，你就会发现上面的事情是显然的。我们都没有实现一个检查监视点是否发生改变的函数！！！</p>
<h2></h2>
<div id="monitor-function"></div>
<h3><font color=#2F5496 face="宋体" size="小三"><strong>实现监视功能</strong> </font></h3>
<hr />
<p>上面我们提到了，我们还需要实现一个检查监视点是否改变的函数<code>int check_wp(type1 param1, ...)</code>。在执行一条指令后逐个检查监视点，如果监视点发生变化，返回<code>1</code>，告诉我们监视内容改变，我们应该中止程序。使程序中止，只需要将全局变量<code>nemu_state.state</code>设置为<code>NEMU_STOP</code>即可。</p>
<p><font color="Sienna" face="宋体" size="小四"><strong>为此，你需要作以下思考(需要写入实验报告中)</strong>：</p>
<ul>
<li><code>check_wp</code>函数的位置应该定义在哪(<code>watchpoint.c</code>, <code>ui.c</code>, <code>cpu-exec.c</code>)，你需要从多角度思考这个问题(可行性、方便性等)</li>
<li><code>check_wp</code>函数应该在哪儿被调用(<code>ui.c</code>的<code>cmd_c()</code>中, <code>cpu-exec.c</code>的<code>cpu-exec()</code>中, <code>exec_once</code>中...)</li>
<li>设置<code>NEMU_STOP</code>状态为什么能让程序中止，而返回到<code>ui_mainloop</code>函数中，将执行权交给用户</li>
</ul>
<p><font color="black" face="宋体" size="小四">厘清上面几个问题，实现监视功能也就很容易了。参考截图如下：</p>
<p>首先是将客户程序内容截图如下作为参考</p>
<p><img src="figs/guest.png" alt="guest-prog" />
注意其中<code>%eax</code>, <code>%ebx</code>, <code>%ecx</code>发生了变化，<code>pc</code>的值当然会变化</p>
<p>因此以下设置四个监视点，然后执行<code>c</code>命令继续运行程序直至监视点发生变化触发中止</p>
<pre><code>w $eax
w $ebx
w $ecx
w $pc
</code></pre>

<p>截图参考如下：</p>
<p><img src="figs/watch.png" />
上面的截图结果仍有缺陷，因为每次发生变化的监视点可能不止一个，比如<code>%eax</code>和<code>pc</code>可能同时发生变化，但是打印结果只打印出最靠前的监视点新旧值。如果你遇到了同样的问题，请思考如何改进。</p>
<div id="file-handin"></div>
<h2></h2>
<h2><font color=#2F5496 face="宋体" size="小三"><strong>提交文件说明</strong> </font></h2>
<p><font face="宋体" size="小四" color="black">请提交以下内容：</p>
<blockquote>
<ul>
<li>nemu项目原码，压缩为zip</li>
<li>nemu项目PA1上的git log日志，保存为txt格式</li>
<li>一个电子版实验报告</li>
</ul>
</blockquote>
<h2><font color=red>请在截止日期前上传至Elearning！</h2>
<h1><font color="blut"><em>本次PA1下此结束了，祝大家测试愉快！</em></h1>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
